!function(e){"use strict";e.module("mde.swipeToRefresh",[]).constant("mdeSwipeToRefreshConfig",{threshold:85})}(angular),function(e){"use strict";function t(t,r,s){function i(i,l,a,c){function m(e){i.state==n.None&&(h=e.touches[0].pageY,l.one("touchend",p),l.bind("touchmove",d),0==u[0].scrollTop&&i.$apply(function(){i.progress=0,i.movement=0}))}function d(e){if(!(u[0].scrollTop>0)){var t=e.touches[0].pageY-h;t>0&&i.state!=n.Pulling&&r(function(){i.state=n.Pulling}),i.state==n.Pulling&&e.preventDefault(),t>0&&i.$apply(function(){i.movement=Math.min(t*o,15*Math.log(t)),i.progress=Math.min(t/i.mdeThreshold,1)})}}function p(o){l.unbind("touchmove",d),i.$apply(function(){1==i.progress?(i.state=n.Updating,i.movement=60,t.when((i.mdeOnRefresh||e.noop)())["finally"](function(){i.state=n.None})):(i.movement>0&&((i.mdeOnCancel||e.noop)(),i.movement=0),r(function(){i.state=n.None},100))})}l.bind("touchstart",m);var u,h;if(c)u=c.getElement();else if(i.mdeScrollHostSelector){for(var f=l.parent();f[0]!=document.body;)if(f=f.parent(),f[0].matches(i.mdeScrollHostSelector)){u=f;break}u=u||f}else u=e.element(document.body);i.mdeThreshold=i.mdeThreshold||s.threshold,i.State=n,i.progress=0,i.state=n.None}return{restrict:"A",require:"?^mdeSwipeToRefreshScrollHost",transclude:!0,scope:{mdeOnRefresh:"&?",mdeOnCancel:"&?",mdeScrollHostSelector:"@?",mdeThreshold:"=?"},templateUrl:"swipe-to-refresh/swipe-to-refresh.html",link:i}}t.$inject=["$q","$timeout","mdeSwipeToRefreshConfig"],e.module("mde.swipeToRefresh").directive("mdeSwipeToRefresh",t);var n={None:"None",Updating:"Updating",Pulling:"Pulling"},o=.7}(angular),function(e){"use strict";function t(){function e(e){function t(){return e}this.getElement=t}return e.$inject=["$element"],{restrict:"A",controller:e}}e.module("mde.swipeToRefresh").directive("mdeSwipeToRefreshScrollHost",t)}(angular),Element.prototype.matches||(Element.prototype.matches=Element.prototype.matchesSelector||Element.prototype.mozMatchesSelector||Element.prototype.msMatchesSelector||Element.prototype.oMatchesSelector||Element.prototype.webkitMatchesSelector||function(e){for(var t=(this.document||this.ownerDocument).querySelectorAll(e),n=t.length;--n>=0&&t.item(n)!==this;);return n>-1}),function(e){try{e=angular.module("mde.swipeToRefresh")}catch(t){e=angular.module("mde.swipeToRefresh",[])}e.run(["$templateCache",function(e){e.put("swipe-to-refresh/swipe-to-refresh.html",'<div\n     class="_indicator-wrap" layout="column" layout-align="center center"\n     ng-style="{top: -40 + movement + \'px\'}">\n    <span class="md-whiteframe-2dp _indicator" ng-if="state == State.Pulling">\n        <md-progress-circular\n                md-diameter="20" value="{{progress*80}}"\n                ng-style="{transform: \'rotate(\' + movement*1.8 + \'deg)\', opacity: progress == 1 ? 1 : .4}">\n        </md-progress-circular>\n    </span>\n    <!--\n    We use ng-show because ng-if will destroy md-progress-circular scope and it will no longer spin while it\'s\n    fading out. It event don\'t freezes in it\'s last state.\n    -->\n    <span class="md-whiteframe-2dp _indicator _updating" ng-show="state == State.Updating">\n        <md-progress-circular md-diameter="20" md-mode="indeterminate"></md-progress-circular>\n    </span>\n</div>\n<div ng-transclude></div>\n')}])}();